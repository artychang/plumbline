'use strict';
import {TestBed} from '@angular/core/testing';
import Rendering from './Rendering';
import {Tester, resolveModule} from './Tester';
import {isValueProvider} from '../utils/utils';
import {initComponent} from '../utils/initComponent';

export default class Renderer {

    tester: Tester<any>;
    completeModule: any = null;
    renderModule: any = null;

    constructor(tester: Tester<any>) {
        this.tester = tester;
        this.completeModule = this.tester.getCompleteModule();
    }

    // Render the entire TestBed of the component + markup
    render(html: any, optionsIn: any): Promise<Rendering> {

        // Options for binding and future customization
        let options = Object.assign({detectChanges: true, bind: {}}, optionsIn);

        // Initialize the markup for the component
        let markupComponent: any = html ? initComponent(html, options.bind) :
            this.tester.testComponent;

        // Generate the complete module from all the pieces
        let copiedSetup = this.completeModule;

        console.log('Renderer markupComponent', markupComponent);

        let configTestingSettings = {
            imports: copiedSetup.imports,
            providers: copiedSetup.providers.map((p) => {
                return this.spyProvider(p);
            }),
            declarations: copiedSetup.declarations.concat([markupComponent]),
            schemas: copiedSetup.schemas,
        };

        this.renderModule = configTestingSettings;

        console.log('Renderer configTestingSettings', configTestingSettings);

        // Start Testing Module using autogenerated custom config settings
        return new Promise<Rendering>((resolve, reject) => {

            /*
            // Detect javascript errors and track them in Jasmine
            if (!("plumbline" in console)) {
                (<any> console).plumbline = {};

                let __error = console.error;
                console.error = function(...args) {

                    // Assert no javascript errors in plumbline
                    if ((<any> console).plumbline.active) {
                        let fullMessage = '';
                        args.forEach((message) => { fullMessage += message + ' '; });
                        expect('javascript errors').toBe('none', fullMessage);
                    }

                    // Still report errors in the debug console
                    __error.apply(console, args);
                };
            }
            */

            try {
                console.log('Renderer configureTestingModule outside');
                // Initialize TestBed for this Component
                TestBed.configureTestingModule(configTestingSettings)
                    .compileComponents().then(() => {
                    let fixture = TestBed.createComponent(markupComponent);

                    if (options.detectChanges) {
                        fixture.detectChanges();
                    }
                    // Return a Rendering object
                    resolve(new Rendering(this.tester, fixture, options.bind));
                });
            } catch (err) {
                console.log(configTestingSettings);
                console.error(err);
            }

        });

    }

    // Spy on all providers
    spyProvider(providerIn: any): any {

        // for arrays, breakdown the individual providers
        if (Array.isArray(providerIn)) {
            return providerIn.map((p) => {
                return this.spyProvider(p);
            });

        } else {

            // Check for providers that come in {provide, useValue} form
            if (isValueProvider(providerIn)) {
                let provide = providerIn.provide;
                let useValue = providerIn.useValue;

                if (provide && !this.tester.dontMock.includes(provide)) {

                    // go through all the objects functions and spyOn the,
                    Object.keys(useValue).forEach(function (key) {
                        if (typeof useValue[key] === 'function') {
                            spyOn(useValue, key).and.callThrough();
                        }
                    });
                    return {provide, useValue};
                }
            } else {
                return providerIn;
            }
        }
    }
}
